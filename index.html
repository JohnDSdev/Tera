<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Gemini Live Hologram â€“ Synced</title>
<style>
body{
  background:#050510;color:#7df;font-family:monospace;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  height:100vh;margin:0;
}
#avatar{
  width:64px;height:128px;
  image-rendering:pixelated;
  filter:drop-shadow(0 0 8px #0ff);
  opacity:0;transition:opacity 1s ease;
}
#status{margin:8px}
button{margin:5px;padding:8px 16px;border:none;border-radius:5px;
  background:#0ff;color:#000;font-weight:bold;cursor:pointer;}
button:disabled{opacity:.4}
</style>
</head>
<body>
<div id="status">Status: idle</div>
<img id="avatar" src="arm_behind_mouth_closed.png" alt="avatar">
<div>
  <button id="connect">Connect</button>
  <button id="end" disabled>End</button>
</div>

<script type="module">
import { GoogleGenAI, Modality } from "https://aistudiocdn.com/@google/genai@1.24.0";

const avatar=document.getElementById("avatar");
const statusEl=document.getElementById("status");
const connectBtn=document.getElementById("connect");
const endBtn=document.getElementById("end");

const frames={
  armClosed:"arm_out_mouth_closed.png",
  armOpen:"arm_out_mouth_open.png",
  backClosed:"arm_behind_mouth_closed.png",
  backOpen:"arm_behind_mouth_open.png"
};

let ai,session,micStream,inCtx,outCtx,analyser;
let mouthTimer,pose=0;
let nextStartTime=0,queueLen=0,closing=false;

function setStatus(t){statusEl.textContent="Status: "+t;}
function setFrame(open){
  if(pose===0)avatar.src=open?frames.backOpen:frames.backClosed;
  else avatar.src=open?frames.armOpen:frames.armClosed;
}

// --- Mouth animation ---
function startMouth(){
  if(mouthTimer)return;
  mouthTimer=setInterval(()=>{
    if(!analyser)return;
    const arr=new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteTimeDomainData(arr);
    let sum=0;for(let i=0;i<arr.length;i++){let f=(arr[i]-128)/128;sum+=f*f;}
    const rms=Math.sqrt(sum/arr.length);
    const open=rms>0.02;
    if(rms>0.05)pose=pose?0:1;
    setFrame(open);
  },80);
}
function stopMouth(){clearInterval(mouthTimer);mouthTimer=null;setFrame(false);}

// --- Connection ---
connectBtn.onclick=async()=>{
  if(session){setStatus("Already connected.");return;}
  closing=false;
  const key=prompt("Enter your Gemini API key:"); if(!key)return;
  setStatus("Connecting...");
  ai=new GoogleGenAI({apiKey:key});
  inCtx=new AudioContext({sampleRate:16000});
  outCtx=new AudioContext({sampleRate:24000});
  analyser=outCtx.createAnalyser(); analyser.connect(outCtx.destination);

  try{micStream=await navigator.mediaDevices.getUserMedia({audio:true});}
  catch(e){setStatus("Mic permission denied");return;}

  const micSrc=inCtx.createMediaStreamSource(micStream);
  const proc=inCtx.createScriptProcessor(4096,1,1);
  micSrc.connect(proc);proc.connect(inCtx.destination);

  session=await ai.live.connect({
    model:"gemini-2.5-flash-native-audio-preview-09-2025",
    callbacks:{
      onopen:()=>{setStatus("Connected");avatar.style.opacity=1;},
      onmessage:onMessage,
      onerror:e=>setStatus("Error: "+e.message),
      onclose:()=>{if(!closing)setStatus("Disconnected");session=null;}
    },
    config:{
      responseModalities:[Modality.AUDIO],
      speechConfig:{voiceConfig:{prebuiltVoiceConfig:{voiceName:"Zephyr"}}},
      systemInstruction:"You are a calm, continuous holographic AI that speaks naturally without repetition."
    }
  });

  proc.onaudioprocess=e=>{
    if(!session)return;
    const d=e.inputBuffer.getChannelData(0);
    const i16=new Int16Array(d.length);
    for(let i=0;i<d.length;i++)i16[i]=d[i]*32768;
    const b64=btoa(String.fromCharCode(...new Uint8Array(i16.buffer)));
    session.sendRealtimeInput({media:{data:b64,mimeType:"audio/pcm;rate=16000"}});
  };

  connectBtn.disabled=true; endBtn.disabled=false;
  setStatus("Live voice chat ready.");
};

// --- Sequential playback ---
function onMessage(msg){
  const data=msg.serverContent?.modelTurn?.parts?.[0]?.inlineData?.data;
  if(!data||!outCtx)return;
  const bytes=Uint8Array.from(atob(data),c=>c.charCodeAt(0));
  const int16=new Int16Array(bytes.buffer);
  const buf=outCtx.createBuffer(1,int16.length,24000);
  const ch=buf.getChannelData(0);
  for(let i=0;i<int16.length;i++)ch[i]=int16[i]/32768;

  // If too much queued, drop earliest buffer
  if(queueLen>3){nextStartTime=outCtx.currentTime;}
  queueLen=Math.max(0,queueLen-buf.duration);

  const src=outCtx.createBufferSource();
  src.buffer=buf; src.connect(analyser);
  const startAt=Math.max(outCtx.currentTime,nextStartTime+0.01);
  nextStartTime=startAt+buf.duration;
  queueLen+=buf.duration;

  if(outCtx.state==="suspended")outCtx.resume();
  src.start(startAt);

  startMouth();
  src.onended=()=>{
    queueLen=Math.max(0,queueLen-buf.duration);
    if(queueLen<=0)stopMouth();
  };
}

// --- End / cleanup ---
endBtn.onclick=()=>{
  closing=true;
  setStatus("Closing...");
  if(session){try{session.close();}catch{} session=null;}
  if(micStream)micStream.getTracks().forEach(t=>t.stop());
  if(inCtx)inCtx.close(); if(outCtx)outCtx.close();
  connectBtn.disabled=false; endBtn.disabled=true;
  stopMouth(); setFrame(false);
  setStatus("Idle");
};
</script>
</body>
</html>
